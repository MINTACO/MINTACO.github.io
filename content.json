{"meta":{"title":"Darren's Blog","subtitle":"纵有疾风起，人生不言弃","description":"前端小白一枚","author":"Darren","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-10T12:08:19.739Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-12-17T08:50:37.079Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-12-16T02:12:10.860Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-11-10T12:08:19.739Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-10T12:08:19.739Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-10T12:08:19.739Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-11-10T12:08:19.739Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-10T12:08:19.755Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-10T12:08:19.755Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-10T12:08:19.755Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-10T12:08:19.755Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-10T12:08:19.755Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"conda命令","slug":"conda命令","date":"2019-12-26T01:23:32.000Z","updated":"2019-12-26T01:51:34.426Z","comments":true,"path":"2019/12/26/conda命令/","link":"","permalink":"/2019/12/26/conda命令/","excerpt":"","text":"转载于微风阳光博客《conda常用命令》&amp;&amp;知乎Chauncey《Conda命令集》 Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换，最流行的 Python 环境管理工具。 1.升级conda update conda conda update anaconda conda update anaconda-navigator //update最新版本的anaconda-navigator 2.添加频道//查看频道 conda config --get channels //删除频道&#39;C1&#39; conda config --remove channels C1 //添加频道&#39;C1&#39; conda config --append channels C1 //添加为Highest Priority conda config --add channels C1 //添加为Lowest Priority conda config --env --add channels C1 //添加到当前激活环境 //添加清华源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ 3.环境管理conda update -n base conda //update最新版本的conda conda create -n xxxx python=xxx //创建python版本还为xxx的xxxx虚拟环境 conda activate xxxx //开启xxxx环境 conda deactivate //关闭环境 conda env list //显示所有的虚拟环境 conda remove —-name xxxx —all //删除环境xxxx conda create -n NewEnv2 —-clone NewEnv //复制NewEnv，新环境名为NewEnv2 4.包管理# 查看包 conda list # 安装&#39;P1 conda install P1 conda install -n NewEnv P1 # 安装到NewEnv环境下 conda install -c C1 P1 #从C1频道安装 # 升级 conda update P1 conda update --all #升级所有 # 想升级conda、R、Python一样的道理 conda update conda conda update r conda update python","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"/tags/Tools/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"list,tuple,dict,set","slug":"list-tuple-dict-set","date":"2019-12-25T02:34:57.000Z","updated":"2019-12-26T01:32:19.180Z","comments":true,"path":"2019/12/25/list-tuple-dict-set/","link":"","permalink":"/2019/12/25/list-tuple-dict-set/","excerpt":"","text":"转载于廖雪峰官网《python教程》 list有序集合，可随时添加和删除其中的元素，例：name = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] list操作 取值通过索引访问元素,索引越界时，会抛出IndexError错误，最后一个元素的索引是len(classmates) - 1。例：name[0] &gt; &#39;Michael&#39;从后往前取还可用负数索引：例：name[-1] &gt; &#39;Tracy&#39; ，以此类推-2，-3 插入元素list.append(obj) 追加元素到末尾list.insert(index,obj) 插入到指定位置 删除元素list.pop(i) 删除索引为i的元素，省略i删除最后一个元素 替换元素list[i] = obj 直接赋值覆盖 tuple有序列表，和list很相似，区别是tuple一旦初始化就不能修改，没有append()，insert()这样的方法。例：name = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。当tuple的元素中有list时，list的元素是可变的，变得是list，不是tuple，tuple元素的指向永远不变 tuple操作 定义tuple时，在定义的时候，tuple的元素就必须被确定下来。定义空tuple：t = ()定义只有一个元素的tuple：t = (1,) 必须加逗号，否则会解析成数字1 取值和list相同 dictPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。例：d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85} dict操作 取值,赋值通过key取值赋值，例：d[&#39;Bob&#39;] &gt; 75 判断key是否在dict中的方法 key in dict 返回布尔值 dict.get(key,自定义value(可省略)) 存在返回对应的value，不存在返回None或者自定义的value 删除key和对应的valuedict.pop(key) dict内部存放的顺序和key放入的顺序是没有关系的,dict的key必须是不可变对象 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 set操作 创建set需要传入一个lists = set([1, 2, 3])=&gt;s &gt; {1, 2, 3}set也是无序的 添加元素s.add(key)可以重复提添加，但会被过滤掉 删除元素s.remove(key) 交集，并集set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： &gt;&gt;&gt; s1 = set([1, 2, 3]) &gt;&gt;&gt; s2 = set([2, 3, 4]) &gt;&gt;&gt; s1 &amp; s2 {2, 3} &gt;&gt;&gt; s1 | s2 {1, 2, 3, 4} set内部不能放可变对象，因为无法判断两个可变对象是否相等，即无法保证无重复元素","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"事件","slug":"事件","date":"2019-12-11T05:57:42.000Z","updated":"2019-12-26T02:11:30.668Z","comments":true,"path":"2019/12/11/事件/","link":"","permalink":"/2019/12/11/事件/","excerpt":"","text":"1.事件流在单击页面中的按钮时，我们也单击了按钮的容器，甚至也单击了整个页面。事件流描述的是从页面中接收事件的顺序。在浏览器发展到第四代时，IE 和 Netscape 开发团队发现这个问题，但他们却提出了差不多是完全相反的事件流的概念。IE 的事件流是事件冒泡流，而 Netscape Communicator 的事件流是事件捕获流。 1.1 事件冒泡即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;Click Me&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 单击了页面中的&lt;div&gt;元素，那么这个 click 事件会按照如下顺序传播：所有现代浏览器都支持事件冒泡，但在具体实现上还是有一些差别。IE5.5 及更早版本中的事件冒泡会跳过元素（从直接跳到 document）。IE9、Firefox、Chrome 和 Safari 则将事件一直冒泡到 window 对象。 1.2 事件捕获事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。以上面的代码为例，捕获过程：虽然事件捕获是 Netscape Communicator 唯一支持的事件流模型，但 IE9、Safari、Chrome、Opera和 Firefox 目前也都支持这种事件流模型。尽管“DOM2 级事件”规范要求事件应该从 document 对象开始传播，但这些浏览器都是从 window 对象开始捕获事件的。事件冒泡可以放心使用，在特殊情况下也可以使用事件捕获。 1.3 DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段(通常算在冒泡阶段)和事件冒泡阶段。多数支持 DOM 事件流的浏览器都实现了一种特定的行为；即使“DOM2 级事件”规范明确要求捕获阶段不会涉及事件目标，但 IE9、Safari、Chrome、Firefox 和 Opera 9.5 及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。 IE8及更早版本不支持DOM事件流 2.事件绑定2.1 DOM0 级事件处理程序通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。简单且可以跨浏览器,但有诸多缺点，如后面的函数会覆盖前面的，在 var btn = document.getElementById(&quot;myBtn&quot;); btn.onclick = function(){ alert(this.id); //&quot;myBtn&quot; }; //this指向当前绑定元素，可以在事件处理程序中通过 this 访问元素的任何属性和方法。 2.2 DOM2 级事件处理程序（IE9、Firefox、Safari、Chrome 和 Opera 支持） addEventListener(事件名,函数名,boolean);boolean为true,事件添加在捕获阶段，为false添加在冒泡阶段；可添加多个函数,函数按照被添加的顺序执行。 removeEventListener(事件名,函数名,boolean);通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过 addEventListener()添加的匿名函数将无法移除，如下面的例子所示。 var btn = document.getElementById(&quot;myBtn&quot;); btn.addEventListener(&quot;click&quot;, function(){ alert(this.id); }, false); //this指向绑定的元素 btn.removeEventListener(&quot;click&quot;, function(){ //没有用！ alert(this.id); }, false); //第二个参数中的函数看似相同，实则是完全不同的函数 解决方法： var btn = document.getElementById(&quot;myBtn&quot;); var handler = function(){ alert(this.id); }; btn.addEventListener(&quot;click&quot;, handler, false); //这里省略了其他代码 btn.removeEventListener(&quot;click&quot;, handler, false); //有效！ 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。 2.3 IE事件处理程序(非DOM)IE 实现了与 DOM 中类似的两个方法： attachEvent(事件名，函数名)由于 IE8 及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段，可绑定多个函数，但是执行顺序与绑定顺序相反。 var btn = document.getElementById(&quot;myBtn&quot;); btn.attachEvent(&quot;onclick&quot;, function(){ alert(&quot;Clicked&quot;); }); //attachEvent()的第一个参数是&quot;onclick&quot;，而非 DOM 的 addEventListener()方法中的&quot;click&quot;。 在 IE 中使用 attachEvent()与使用 DOM0 级方法的主要区别在于事件处理程序的作用域。在使用 attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window。 var btn = document.getElementById(&quot;myBtn&quot;); btn.attachEvent(&quot;onclick&quot;, function(){ alert(this === window); //true }); detachEvent(事件名，函数名)同样的需传入与attachEvent()相同的参数，并且匿名函数不能被移除。 IE11已不支持attachEvent()方法 2.4 跨浏览器兼容写法//没有改变IE中的this指向，仍指向window var EventUtil = { addHandler: function(element, type, handler){ if (element.addEventListener){ element.addEventListener(type, handler, false); } else if (element.attachEvent){ element.attachEvent(&quot;on&quot; + type, handler); } else { element[&quot;on&quot; + type] = handler; } }, removeHandler: function(element, type, handler){ if (element.removeEventListener){ element.removeEventListener(type, handler, false); } else if (element.detachEvent){ element.detachEvent(&quot;on&quot; + type, handler); } else { element[&quot;on&quot; + type] = null; } } }; 3.事件对象触发DOM事件时，会产生一个事件对象event，对象中包含与事件有关的信息。包括触发事件的元素，事件类型，及其他特定信息。所有浏览器都支持DOM对象，但支持方式不同。只有在触发事件执行期间event对象才会存在，执行完即销毁 3.1 DOM中事件对象兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0 级或 DOM2 级），都会传入 event 对象。所有事件都会有以下event属性和方法： 常用属性： currentTarget 和 target 与 this document.body.onclick = function(event){ alert(event.currentTarget === document.body); //true alert(this === document.body); //true alert(event.target === document.getElementById(&quot;myBtn&quot;)); //true }; //target指向触发事件的真正目标，button上的事件冒泡到了document.body 可以通过target在用addEventListener/attachEvent绑定事件时传值: oBtn._params = [0,1,2]; EventUtil.addHandler(oBtn,&quot;click&quot;,function(ev){ console.log(ev); console.log(ev.target._params) }) type通过一个函数处理多个事件 var oBtn = document.getElementById(&#39;btn&#39;); function handleClick(ev){ switch(ev.type){ case &quot;click&quot;: console.log(&quot;click&quot;); break; case &quot;mouseover&quot;: console.log(&quot;mouseover&quot;); break; case &quot;mouseout&quot;: console.log(&quot;mouseout&quot;); break; } }; EventUtil.addHandler(oBtn,&quot;click&quot;,handleClick); EventUtil.addHandler(oBtn,&quot;mouseover&quot;,handleClick); EventUtil.addHandler(oBtn,&quot;mouseout&quot;,handleClick); preventDefault()阻止事件的默认行为,cancelable为true可用var link = document.getElementById(&quot;myLink&quot;); link.onclick = function(ev){ ev.preventDefault(); }; stopPropagation()阻止事件进一步传播，bubbles为true可用document.body.onclick = function(){ console.log(&quot;body&quot;); } oBtn.onclick = function(ev){ console.log(&quot;button&quot;); ev.stopPropagation(); } //点击button不会触发body上的方法 3.2 IE中事件对象3.3 兼容写法var EventUtil = { addHandler: function(element, type, handler){ if (element.addEventListener){ element.addEventListener(type, handler, false); } else if (element.attachEvent){ element.attachEvent(&quot;on&quot; + type, handler); } else { element[&quot;on&quot; + type] = handler; } }, removeHandler: function(element, type, handler){ if (element.removeEventListener){ element.removeEventListener(type, handler, false); } else if (element.detachEvent){ element.detachEvent(&quot;on&quot; + type, handler); } else { element[&quot;on&quot; + type] = null; } }, getEvent: function(event){ return event ? event : window.event; }, getTarget: function(event){ return event.target || event.srcElement; }, preventDefault: function(event){ if (event.preventDefault){ event.preventDefault(); } else { event.returnValue = false; } }, stopPropagation: function(event){ if (event.stopPropagation){ event.stopPropagation(); } else { event.cancelBubble = true; } } };","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"/tags/Javascript/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"DOM","slug":"DOM","date":"2019-11-27T06:43:33.000Z","updated":"2019-12-26T02:11:30.668Z","comments":true,"path":"2019/11/27/DOM/","link":"","permalink":"/2019/11/27/DOM/","excerpt":"","text":"1.DOM:Document Object Model(文档对象模型)DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。DOM 描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM 脱胎于Netscape 及微软公司创始的 DHTML（动态 HTML），但现在它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。 IE 中的所有 DOM 对象都是以 COM 对象的形式实现的。这意味着 IE 中的DOM 对象与原生 JavaScript 对象的行为或活动特点并不一致。 2.节点层次2.1 Node类型2.1.1 确定节点类型DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现。这个 Node 接口JavaScript 中是作为 Node 类型实现的；除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。 每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列12 个数值常量来表示，任何节点类型必居其一： Node.ELEMENT_NODE(1)； Node.ATTRIBUTE_NODE(2)； Node.TEXT_NODE(3)； Node.CDATA_SECTION_NODE(4)； Node.ENTITY_REFERENCE_NODE(5)； Node.ENTITY_NODE(6)； Node.PROCESSING_INSTRUCTION_NODE(7)； Node.COMMENT_NODE(8)； Node.DOCUMENT_NODE(9)； Node.DOCUMENT_TYPE_NODE(10) Node.DOCUMENT_FRAGMENT_NODE(11) Node.NOTATION_NODE(12)。 nodeType确定节点类型someNode.nodeType 返回值：节点类型的数字值nodeName 节点名nodeValue 内容，对于元素节点，始终为null 2.1.2 节点关系 父子节点 ：上下两层节点之间的关系。每个节点都有childNodes属性,其中保存着一个 NodeList 对象(类数组)，DOM 结构动态变动会直接反映在NodeList对象中，对应的其中的所有节点都有对应的唯一父节点parentNode。 访问：var firstChild = someNode.childNodes[0]/firstChild; var lastChild = someNode.childNodes[someNode.childNodes.length-1]/lastChild; var secondChild = someNode.childNodes.item(1); var count = someNode.childNodes.length; 将NodeList转化为数组： function convertToArray(nodes){ var array = null; try { array = Array.prototype.slice.call(nodes, 0); //针对非 IE 浏览器 } catch (ex) { array = new Array(); for (var i=0, len=nodes.length; i &lt; len; i++){ array.push(nodes[i]); } } return array; } 由于IE8 及更早版本将 NodeList实现为一个 COM 对象，不能直接截取 判断是否有子节点hasChildNodes()在节点包含一或多个子节点的情况下返回 true,比判断length更方便。 同胞节点 ：包含在childNodes 列表中的每个节点相互之间都是同胞节点。previousSibling和 nextSibling 属性 2.1.3 操作节点父节点基础上的操作 parentNode.appendChild( newNode ) parentNode.insertBefore( newNode,参照节点 ) parentNode.replaceChild( newNode,要替换的节点 )以上对节点的操作均为剪切，而非复制 parentNode.removeChild( 要删除的节点 ) 所有节点公有方法 cloneNode( true/false )创建调用这个方法的节点的一个完全相同的副本,参数为 true的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为 false 的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点副本就成为了一个“孤儿”，除非通过 appendChild()、insertBefore()或 replaceChild()将它添加到文档中。 &lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt; &lt;/ul&gt; var deepList = myList.cloneNode(true); alert(deepList.childNodes.length); //3（IE &lt; 9）或 7（其他浏览器） var shallowList = myList.cloneNode(false); alert(shallowList.childNodes.length); //0 cloneNode()方法不会复制添加到 DOM 节点中的 JavaScript 属性，例如事件处理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点，其他一切都不会复制。IE 在此存在一个 bug，即它会复制事件处理程序，所以我们建议在复制之前最好先移除事件处理程序。 normalize() 2.2 Document类型JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。特征： nodeType 的值为 9； nodeName 的值为”#document”； nodeValue 的值为 null； parentNode 的值为 null； ownerDocument 的值为 null； 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或 Comment。 2.2.1 常用子节点var html = document.documentElement; var body = document.body; //取得文档标题 var originalTitle = document.title; //取得完整的 URL var url = document.URL; //取得域名 var domain = document.domain; //取得来源页面的 URL var referrer = document.referrer; 2.2.3 查找元素 getElementById( ID )ID:要取得的元素的 ID。如果找到相应的元素则返回该元素，如果不存在带有相应 ID 的元素，则返回 null。注意，这里的 ID 必须与页面中元素的 id特性（attribute）严格匹配，包括大小写。如果页面中多个元素的 ID 值相同，getElementById()只返回文档中第一次出现的元素。 getElementsByTagName( 元素标签名 )[]返回一个HTMLCollection对象,动态集合。可以按索引访问，也可以按名称。 可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用 item()，而对字符串索引就会调用 namedItem()。最好区分大小写。 var images = document.getElementsByTagName(&quot;img&quot;); alert(images.length); //输出图像的数量 alert(images[0].src); //输出第一个图像元素的 src 特性 alert(images.item(0).src); //输出第一个图像元素的 src 特性 //HTMLCollection 对象还有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name特性取得集合中的项。 &lt;img src=&quot;myimage.gif&quot; name=&quot;myImage&quot;&gt; var myImage = images.namedItem(&quot;myImage&quot;); var myImage = images[&quot;myImage&quot;]; //取得所有元素 var allElements = document.getElementsByTagName(&quot;*&quot;); getElementsByName()只有 HTMLDocument 类型才有的方法. &lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt; &lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;green&quot; name=&quot;color&quot; id=&quot;colorGreen&quot;&gt; &lt;label for=&quot;colorGreen&quot;&gt;Green&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt; &lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/fieldset&gt; var radios = document.getElementsByName(&quot;color&quot;); //与 getElementsByTagName() 类似， getElementsByName() 方法也会返回一个 HTMLCollectioin 。 //但是，对于这里的单选按钮来说， namedItem() 方法则只会取得第一项（因为每一项的 name 特性都相同） 特殊集合document.anchors ，包含文档中所有带 name 特性的 元素；document.forms ， 包含文档中所有的 元素；document.images ，包含文档中所有的 元素；document.links ，包含文档中所有带 href 特性的 元素。 2.3 Element 类型Element 类型用于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问。特征：nodeType 的值为 1；nodeName 的值为元素的标签名；nodeValue 的值为 null ；parentNode 可能是 Document 或 Element ；其子节点可能是 Element 、 Text 、 Comment 、 ProcessingInstruction 、 CDATASection 或EntityReference 。 //1.取元素名，nodeName/tagName if (element.tagName.toLowerCase() == &quot;div&quot;){ //这样最好（适用于任何文档） } //2.操作特性 getAttribute() 、 setAttribute( 要设置的特性名 ，值 ) 和 removeAttribute() //对于style 属性和onclick类似的事件，getAttribute() 返回的是css文本和事件相应代码的字符串，一般不使用 getAttribute() ，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用 getAttribute() 方法。 // 如果特性不存在， setAttribute()则创建该属性并设置相应的值，通过这个方法设置的特性名会被统一为小写形式。推荐通过属性来设置特性。 //3.创建元素 document.createElement(标签名) var div = document.createElement(&quot;div&quot;); 创建完后要使用appendChild() 、 insertBefore() 或 replaceChild() 方法将元素插入到文档数中，才会在浏览器中显示。","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"/tags/Javascript/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"JSON.stringify/JSON.parse技巧","slug":"JSON-stringify-JSON-parse技巧","date":"2019-11-19T02:40:57.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/11/19/JSON-stringify-JSON-parse技巧/","link":"","permalink":"/2019/11/19/JSON-stringify-JSON-parse技巧/","excerpt":"","text":"JSON.stringify()的作用是将js对象转换为 JSON 字符串，而JSON.parse()可以将JSON字符串转为一个对象。 1.深度拷贝在实际开发中，为了不影响原对象，可利用JSON.parse( JSON.stringify(obj) )深度拷贝原obj的副本。 2.判断数组中是否包含某对象//判断数组是否包含某对象 let data = [ {name:&#39;hi&#39;}, {age:&#39;13&#39;}, {job:&#39;coder&#39;}, ], val = {name:&#39;hi&#39;}; JSON.stringify(data).indexOf(JSON.stringify(val)) !== -1;//true 3.判断对象（数组）是否相等 let a = [1,2,3], b = [1,2,3]; console.log(JSON.stringify(a) === JSON.stringify(b));","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"/tags/Javascript/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"BOM(Browser Object Model 浏览器对象模型)","slug":"BOM","date":"2019-11-17T08:34:06.000Z","updated":"2019-12-26T02:11:30.668Z","comments":true,"path":"2019/11/17/BOM/","link":"","permalink":"/2019/11/17/BOM/","excerpt":"","text":"&emsp;&emsp;ECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript，那么 BOM（浏览器对象模型）则无疑才是真正的核心。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。多年来，缺少事实上的规范导致 BOM 既有意思又有问题，因为浏览器提供商会按照各自的想法随意去扩展它。于是，浏览器之间共有的对象就成为了事实上的标准。这些对象在浏览器中得以存在，很大程度上是由于它们提供了与浏览器的互操作性。W3C 为了把浏览器中 JavaScript 最基本的部分标准化，已经将 BOM 的主要方面纳入了 HTML5 的规范中。 1.window对象&emsp;&emsp;BOM 的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。这意味着在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问parseInt()等方法。 1.1 全局作用域有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法。但定义全局变量与在 window 对象上直接定义属性还是有一点差别： 全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。var age = 29; window.color = &quot;red&quot;; //在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 false delete window.age; //在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 true delete window.color; //returns true alert(window.age); //29 alert(window.color); //undefined 直接访问未定义的变量会抛出错误，但是访问未定义的window属性则不会，会返回undefined。可以知道某个可能未声明的变量是否存在。1.2 导航和打开窗口函数：window.open(URL,窗口目标，特性字符串，是否打开新页面标志)；四个参数中，一般只需要传URL，最后一个参数传_self时新窗口覆盖当前窗口，默认为打开新窗口。特性表：表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格），如下面的例子所示。window.open(&quot;http://www.baidu.com&quot;,&quot;wroxWindow&quot;, &quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); 返回值：新打开窗口的window对象opener属性：新打开的窗口都有一个opener属性，保存着打开它的原始窗口的window对象。但原始窗口中并没有这样的指针指向弹出窗口。可指定opener为null；opener.close()：可以关闭本窗口中通过js打开的窗口；不同浏览器使用close()方法的策略不同： ff : 无法关闭 chrome : 直接关闭 ie : 询问用户 &lt;button&gt;open&lt;/button&gt; &lt;button&gt;close&lt;/button&gt; &lt;script&gt; var oBtn = document.getElementsByTagName(&#39;button&#39;)[0]; var oBtn1 = document.getElementsByTagName(&#39;button&#39;)[1]; var wroxWin; oBtn.onclick = function(){ wroxWin = window.open(&quot;http://www.baidu.com/&quot;,&quot;wroxWindow&quot;, &quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); // wroxWin.opener = null; console.log(wroxWin); }; oBtn1.onclick = function(){ wroxWin.close(); } &lt;/script&gt; 1.3 窗口尺寸1.3.1可视区尺寸document.documentElement.clientWidthdocument.documentElement.clientHeight 1.3.2 滚动条滚动距离var scrollTop = document.documentElement.scrollTop || document.body.scrollTop(Left) 1.3.3 内容高度（宽度）Element.scrollHeight (Width)这个只读属性是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。 1.3.4 offsetHeight /WidthHTMLElement.offsetHeight 是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。通常，元素的offsetHeight是一种元素CSS高度的衡量标准，包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包含:before或:after等伪类元素的高度。对于文档的body对象，它包括代替元素的CSS高度线性总含量高。浮动元素的向下延伸内容高度是被忽略的。这个属性值会被四舍五入为整数值，如果你需要一个浮点数值，请用 element.getBoundingClientRect(). 2.location对象最有用的BOM对象之一，既是window的属性，又是document的属性。location存储着当前文档的信息，并且将 URL 解析为独立的片段，可以通过location对象的属性访问，下面是所有的location属性： 2.1 获取包含查询字符串的对象function getQueryStringArgs(){ //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), //保存数据的对象 args = {}, //取得每一项 items = qs.length ? qs.split(&quot;&amp;&quot;) : [], item = null, name = null, value = null, //在 for 循环中使用 i = 0, len = items.length; //逐个将每一项添加到 args 对象中 for (i=0; i &lt; len; i++){ item = items[i].split(&quot;=&quot;); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) { args[name] = value; } } return args; } 2.2 改变浏览器位置 location.assign( URL )方法:立即打开新 URL 并在浏览器的历史记录中生成一条记录。修改window.location或者location.href也会调用assign方法，效果相同。修改表中location的属性也可改变浏览器位置。 location.replace( URL ),载入新页面且不会生成历史记录，无法回退。 location.reload( true(可选) ),重新载入页面，如果调用 reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，需加参数true。位于 reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将 reload()放在代码的最后一行。","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"/tags/Javascript/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"vue组件","slug":"vue组件","date":"2019-11-15T08:07:00.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/11/15/vue组件/","link":"","permalink":"/2019/11/15/vue组件/","excerpt":"","text":"1.组件好处方便复用，易于维护 2.组件定义分为全局组件和局部组件，组件里的data必须写成函数形式，使每个组件的data有独立的作用域，否则复用时会出现干扰。命名采用大驼峰/小驼峰，用时可以为连字符。注意项 组件在html中不能写成自闭合标签； 在html中不能使用大驼峰式，会被解析成小驼峰，以至于找不到组件，最好写成连字符形式。 &lt;div id=&quot;app&quot;&gt; &lt;hello-world&gt;&lt;/hello-world&gt; &lt;/div&gt; &lt;script&gt; //全局组件 // Vue.component(&#39;hello-world&#39;, { //组件里的数据要求写成函数 // data () { // return { // msg: &#39;hello world&#39; // } // }, // template: `&lt;div&gt;{{ msg }}&lt;/div&gt;` // }) //局部组件 const vm = new Vue({ el: &#39;#app&#39;, components: { helloWorld: { data () { return { msg: &#39;hello world&#39; } }, template: `&lt;div&gt;{{ msg }}&lt;/div&gt;` } } }) &lt;/script&gt; 3.组件间数据传递3.1 父传子3.1.1 通过prop向子组件传递数据Prop 是在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。 Vue.component(&#39;blog-post&#39;, { props: [&#39;title&#39;], template: &#39;&lt;h3&gt;{{ title }}&lt;/h3&gt;&#39; }) 一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问 data 中的值一样。 prop类型 字符串数组，如:props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;] 对象，在每个prop的值都需要特定类型时，对象的名称和值分别是 prop 各自的名称和类型匹配要求，如: props: { // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: &#39;hello&#39; } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !== -1 } } // prop 会在一个组件实例创建之前进行验证，所以实例的属性 (如 data、computed 等) 在 default 或 validator 函数中是不可用的。 } 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致应用的数据流向难以理解。 两种常见的试图改变一个 prop 的情形： 这个 prop 用来传递一个初始值；最好定义一个本地的 data 属性并将这个 prop 用作其初始值：props: [&#39;initialCounter&#39;], data: function () { return { counter: this.initialCounter } } 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：props: [&#39;size&#39;], computed: { normalizedSize: function () { return this.size.trim().toLowerCase() } } 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。 3.1.2 vm.$attrs配合inheritAttrs:false$attrs包含未注册的属性,inheritAttrs:false 使没有被注册的属性也不会显示在行间 &lt;div id=&quot;app&quot;&gt; &lt;my-content :title=&quot;title&quot; :content=&quot;content&quot; :index=&quot;index&quot;&gt; &lt;/my-content&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el:&#39;#app&#39;, data:{ title:&quot;标题&quot;, content:&#39;我是内容&#39;, index:20 }, components:{ myContent:{ props:[&#39;title&#39;], inheritAttrs:false, created(){ console.log(this.$attrs) }, template:`&lt;div&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;my-p v-bind=&quot;$attrs&quot;&gt;&lt;/my-p&gt; &lt;/div&gt;`, components:{ myP:{ created(){ console.log(this.$attrs) }, props:[&#39;content&#39;], template:`&lt;p&gt;{{content}}&lt;/p&gt;` } } } } }) &lt;/script&gt; 输出： 3.1.3 vm.$parent/vm.$children&lt;div id=&quot;app&quot;&gt; &lt;my-content&gt; &lt;/my-content&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el:&#39;#app&#39;, data:{ title:&quot;标题&quot;, content:&#39;我是内容&#39;, index:20 }, components:{ myContent:{ created(){ console.log(this.$parent); //父级vue实例 this.title = this.$parent.title; // this.content = this.$parent.content; }, mounted(){ console.log(this.$children); // 数组，包含子组件实例 }, template:`&lt;div&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;my-p &gt;&lt;/my-p&gt; &lt;/div&gt;`, components:{ myP:{ created(){ console.log(this.$parent); this.content = this.$parent.$parent.content; }, template:`&lt;p&gt;{{content}}&lt;/p&gt;` } } } } }) &lt;/script&gt; 输出： 3.1.4 provide-inject &lt;div id=&quot;app&quot;&gt; &lt;my-content&gt; &lt;/my-content&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el:&#39;#app&#39;, provide:{ title:&quot;标题&quot;, content:&#39;我是内容&#39;, index:20 }, components:{ myContent:{ inject:[&#39;title&#39;], template:`&lt;div&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;my-p &gt;&lt;/my-p&gt; &lt;/div&gt;`, components:{ myP:{ inject:[&#39;content&#39;], template:`&lt;p&gt;{{content}}&lt;/p&gt;` } } } } }) &lt;/script&gt; 3.2 子传父3.2.1 通过引用 ref引用 ref 可以用在Dom上/组件上 ，通过this.$refs可以获取dom或者组件实例。不能赋值名字相同的ref，后面的会覆盖前者，除非是v-for生成的循环，例子：&lt;div ref=&quot;dom&quot; v-for=&quot;item in 5&quot;&gt;hi&lt;/div&gt;,此时this.$refs.dom会输出数组[div,div,div,div,div]。在父组件中通过this.$refs.子组件可以获取子组件的实例，进而获取子组件的数据和方法。 3.2.2 通过函数传值，$emit/$listeners$emit主动触发绑定的事件,第一个参数为事件名，第二个参数为要传递的参数 &lt;div id=&quot;app&quot;&gt; &lt;my-cmp @click=&quot;func&quot;&gt;&lt;/my-cmp&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el:&quot;#app&quot;, methods:{ func(data){ console.log(data); } }, components:{ myCmp:{ template:`&lt;div&gt; &lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt; &lt;/div&gt;`, methods:{ handleClick(){ this.$emit(&#39;click&#39;,this.msg); } }, data(){ return { msg:&quot;hello world&quot; } } } } }) &lt;/script&gt; $listeners,通过v-on=“$listeners”获得组件上所有通过@绑定的事件，但是不能传参 &lt;div id=&quot;app&quot;&gt; &lt;my-cmp @click=&quot;func&quot; @mousedown=&quot;func1&quot;&gt;&lt;/my-cmp&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el:&quot;#app&quot;, methods:{ func(data){ console.log(data); }, func1(){ console.log(&#39;func1&#39;); } }, components:{ myCmp:{ template:`&lt;div&gt; &lt;button v-on=&quot;$listeners&quot;&gt;click&lt;/button&gt; &lt;/div&gt;`, } } }) &lt;/script&gt; 3.3 兄弟组件传值3.3.1 事件总线event bus&lt;div id=&quot;app&quot;&gt; &lt;my-input&gt;&lt;/my-input&gt; &lt;hr /&gt; &lt;my-content&gt;&lt;/my-content&gt; &lt;/div&gt; &lt;script&gt; // event bus 事件总线 // vue 实例 一个兄弟组件触发的同时另一个监听 Vue.prototype.bus = new Vue(); const vm = new Vue({ el: &#39;#app&#39;, components: { myContent: { data () { return { content: &#39;&#39; } }, created () { this.bus.$on(&#39;click&#39;, content =&gt; { this.content = content; }) }, template: `&lt;div&gt;{{ content }}&lt;/div&gt;` }, myInput: { data () { return { inputVal: &#39;&#39; } }, methods: { handleClick () { console.log(this.inputVal); this.bus.$emit(&#39;click&#39;, this.inputVal); } }, template: `&lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputVal&quot;/&gt; &lt;button @click=&quot;handleClick&quot;&gt;提交&lt;/button&gt; &lt;/div&gt;` } } }) &lt;/script&gt;","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"filter","slug":"filter","date":"2019-11-15T07:15:22.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/11/15/filter/","link":"","permalink":"/2019/11/15/filter/","excerpt":"","text":"vue过滤器在不改变原有数据的情况下改变要显示内容。 &lt;div id=&quot;app&quot;&gt; {{ money | toMoney(a) | test }} &lt;/div&gt; &lt;script&gt; //filter全局，第一个参数value一定是管道符之前的值，这里就是money Vue.filter(&#39;toMoney&#39;, (value, times) =&gt; { return (value * times).toLocaleString(); }); //这里的value是10000 Vue.filter(&#39;test&#39;, value =&gt; { console.log(value); return value; }) var vm = new Vue({ el: &#39;#app&#39;, data: { a: 10, money: 1000 }, }) &lt;/script&gt;","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"vue生命周期及钩子函数","slug":"vue生命周期及钩子函数","date":"2019-11-13T12:37:11.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/11/13/vue生命周期及钩子函数/","link":"","permalink":"/2019/11/13/vue生命周期及钩子函数/","excerpt":"","text":"1.生命周期图示 2. 钩子函数&lt;div id=&quot;app&quot;&gt;{{ name }} {{ age }}&lt;/div&gt; &lt;script&gt; const vm = new Vue({ el: &#39;#app&#39;, data: { name: &#39;lushuo&#39;, age: 23 }, beforeCreate () { // x // 不能获取data // console.log(this); // console.log(this.$data); console.log(&#39;beforeCreate&#39;);s }, created () { // 调用ajax // console.log(this.$data); console.log(&#39;created&#39;); }, //挂载 beforeMount () { // x console.log(this.$el); }, mounted () { // ajax console.log(this.$el); }, beforeUpdate () { this.age = 16; console.log(&#39;beforeUpdate&#39;); }, updated () { // this.age = 19; console.log(&#39;updated&#39;); }, beforeDestroy () { // 定时器清除 console.log(&#39;destroy&#39;); }, destroyed () { console.log(&#39;destroyer&#39;); } }) &lt;/script&gt;","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"vue挂载流程，render函数","slug":"vue挂载流程，render函数","date":"2019-11-13T12:21:34.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/11/13/vue挂载流程，render函数/","link":"","permalink":"/2019/11/13/vue挂载流程，render函数/","excerpt":"","text":"1.Vue挂载流程图 2.render函数const vm = new Vue({ el: &#39;#app&#39;, // template: &#39;&lt;h2&gt;{{ msg }}&lt;/h2&gt;&#39;, //render的第一个参数一定是creatElement函数，写成其他名称也是 render ( h ) { return h(&#39;h1&#39;, { //属性 class: &#39;haha&#39;, style: { color: &#39;red&#39;, fontSize: &#39;12px&#39; } },[ //子元素 &#39;我是一个h1标题&#39;, h(&#39;p&#39;, &#39;我是一个p标签&#39;) ]) // const tag = &quot;div&quot;; // return ( // &lt;tag // class=&quot;haha&quot; // style={{color: 'red', fontSize: '12px'}} // on-click={()=&gt;{console.log(&#39;haha&#39;)}} // &gt; // &lt;p&gt;哈哈&lt;/p&gt; // &lt;/tag&gt; // ) // return h( // &#39;h1&#39;, // { // class:&#39;haha&#39;, // style:{ // color:&#39;blue&#39;, // fontSize:&#39;20px&#39; // } // },&#39;hello&#39; // ) }, })","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"计算属性与侦听器","slug":"计算属性与侦听器","date":"2019-11-13T06:13:51.000Z","updated":"2019-12-26T02:11:30.668Z","comments":true,"path":"2019/11/13/计算属性与侦听器/","link":"","permalink":"/2019/11/13/计算属性与侦听器/","excerpt":"","text":"1.计算属性虽然插值表达式中可以插入复杂逻辑，但过于臃肿且难以复用，对于复杂逻辑，应使用计算属性。 基础例子： &lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#example&#39;, data: { message: &#39;Hello&#39; }, computed: { // 计算属性的 getter reversedMessage: function () { // `this` 指向 vm 实例 return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;) } } }) &lt;/script&gt; 计算属性相当于一层缓存，每次都从缓存中取值，只有设计的数据更改后才会重新执行此函数。直接引用，不比写成”reversedMessage()”形式。 1.1 计算属性与方法比较上面的例子在插值表达式中调用方法同样可以实现，如: &lt;p&gt;Reversed message: &quot;{{ reversedMessage() }}&quot;&lt;/p&gt; // 在组件中 methods: { reversedMessage: function () { return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;) } } 两者的不同： 计算属性是响应式的，只要message的值没有改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，相当于缓存，不必再次执行函数； 相比之下，每次重新渲染调用方法总会重新执行函数，费时费力。但是在不需要缓存的情况下可以使用方法。 1.2 计算属性对象形式涉及双向绑定时可以用计算属性的对象形式，不常用。例： &lt;div id=&quot;app&quot;&gt; 计算相加: &lt;input type=&quot;text&quot; v-model.number=&quot;firstCount&quot; /&gt; + &lt;input type=&quot;text&quot; v-model.number=&quot;lastCount&quot; /&gt; &lt;p&gt; 计算结果: &lt;input type=&quot;text&quot; v-model=&quot;sum&quot; /&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { firstCount: null, lastCount: null, }, computed: { sum: { get () { if(!this.firstCount &amp;&amp; !this.lastCount) { return null; } return this.firstCount + this.lastCount; }, set (val) { const avg = val / 2; this.firstCount = avg; this.lastCount = avg; } } } }) &lt;/script&gt; 2.侦听器watch&lt;div id=&quot;app&quot;&gt; {{ person }} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { name: &#39;lushuo&#39;, age: 18, person:&#39;&#39; }, // created(){ // this.age = 23; // }, watch: { // 被观察的属性变化，就会执行相应的函数 // name改变触发name函数，age改变触发age函数 // 首次刷新页面时不执行，可以配合methods和生命周期函数来实现 // name (newVal) { // // newVal 是更改后的值 // this.person = `姓名：${newVal} 年龄：${this.age}`; // }, // age (newVal) { // this.person = `姓名：${this.name} 年龄：${newVal}`; // } // watch不仅可以写成函数的形式，还可以写成对象的形式 // 可以填写其他参数，如immediate：true, 无论有没有数据改变，立即执行 // 填写immediate后，就不需要配合methods和生命周期函数了 name: { handler (newVal) { setTimeout (() =&gt; { this.person = `姓名：${newVal} 年龄：${this.age}`; }, 2000) }, immediate: true }, age: { handler (newVal) { setTimeout (() =&gt; { this.person = `姓名：${this.name} 年龄：${newVal}`; }, 2000) }, immediate: true } } }) &lt;/script&gt; 3.总结3.1 computed和watch的区别 computed不可执行异步，watch可执行异步； computed可以观察多个数据，watch只观察一个； computed可以新生成一个数据，直接在视图中渲染；watch不可，他用的是本身存在的数据，data中存在。 3.2 computed和methods的区别computed有缓存机制，methods无缓存机制。 3.3 数据查找顺序data &gt; methods &gt; computed","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"vue插值表达式","slug":"vue插值表达式","date":"2019-11-12T01:01:59.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/11/12/vue插值表达式/","link":"","permalink":"/2019/11/12/vue插值表达式/","excerpt":"","text":"简介Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值，即插值表达式。 用法1.插值表达式中使用的数据必须先在data中存在，才能实现数据绑定；2.支持js表达式,但不支持语句及流控制，可用三目表达式；2.要更改的数据必须先存在，视图才会刷新；3.通过索引或者长度的方式改变数组，视图不会刷新，必须使用数组的变异方法，如push、pop、shift、unshift、sort、reverse、splice；4.$set可用来更改对象的值，例：vm.$set(vm.obj, &#39;xxx&#39;, 90);;也可以更改其他元素，大多用来更改对象。 &lt;div id=&quot;app&quot;&gt; {{ 'a' }}&lt;br/&gt; {{ 1 }}&lt;br/&gt; {{ true }}&lt;br/&gt; {{ [1, 2, 3] }}&lt;br/&gt; {{ {a: 1, b: 10} }}&lt;br/&gt; {{ 1+1 }}&lt;br/&gt; {{ 1-1 }}&lt;br/&gt; {{ 'a' + 'b' }}&lt;br/&gt; &lt;!-- {{ var a = 10; return a; }} 语句不支持&lt;br/&gt; {{ if(true) { return 'a'} }} 流控制不支持，可用三元表达式&lt;br/&gt; --&gt; {{ !true ? 'a' : 'b' }}&lt;br/&gt; {{ name }}&lt;br/&gt; {{ desc }}&lt;br/&gt; {{ arr[0] }}&lt;br/&gt; {{ obj[\"b\"] }}&lt;br/&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el:&quot;#app&quot;, data:{ name: &#39;ls&#39;, desc: &#39;coder&#39;, arr: [1, 2, 3], obj: { a: 1, b: 10 } } }) // vm.$mount(&#39;#app&#39;);另一种挂载方法 // $el 返回vue作用的DOM元素 &lt;/script&gt;","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"vue指令","slug":"vue指令","date":"2019-11-12T00:58:37.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/11/12/vue指令/","link":"","permalink":"/2019/11/12/vue指令/","excerpt":"","text":"v-pre 跳过该元素和它的子元素的变异过程，显示原始的{ { } }的标签 v-cloak 该指令保持在元素上，直到关联实例结束变异 可与css配合使用隐藏未编译的{ { } }标签 v-once 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。vue内部进行了缓存，以后使用的值都是缓存里的结果 v-html === innerHTML XSS 更新元素的innerHTML v-text === innerText 更新元素的innerText，不常用，一般直接使用{ { } } v-if 控制元素是否存在 判断多个相同状态的用标签包裹 v-else – 配合v-if，两者必须相邻 v-else-if 同理 v-show 控制元素的dispaly样式 v-show和v-if的区别？ v-if是控制该元素是否存在，值为false时，完全移除该元素v-show是控制该元素的样式(display)，值为false时，元素的display为none v-if支持template标签v-show不支持template标签 v-bind&lt;=&gt;： 绑定属性，当绑定class，style时有两种方式，绑定多个属性可用[],需条件判断可用{} v-on&lt;=&gt;@ 监听事件this指向 methods里的函数this指向vue实例 函数不可写在data里，this指向window 组件无法识别点击事件，可以加修饰符native让组件拥有原生属性,例子：&lt;my-cmp ref=&quot;cmp&quot; @click.native=&quot;func&quot;&gt; &lt;/my-cmp&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-once&gt; {{a}} &lt;/div&gt; &lt;div v-html=&quot;dom&quot;&gt;&lt;/div&gt; &lt;template v-if=&quot;flag&quot;&gt; &lt;div&gt;123&lt;/div&gt; &lt;div&gt;456&lt;/div&gt; &lt;/template&gt; &lt;div v-if=&quot;count === 1&quot;&gt;hello&lt;/div&gt; &lt;div v-else-if=&quot;count === 2&quot;&gt;hi&lt;/div&gt; &lt;div v-else&gt;world&lt;/div&gt; &lt;div v-show=&quot;true&quot;&gt;v-show&lt;/div&gt; &lt;img :src=&quot;imgUrl&quot; alt=&quot;&quot; class=&quot;red&quot; :class=&quot;{ red : flag}&quot; /&gt; &lt;div style=&quot;width: 500px; height: 500px;&quot; :style=&quot;[divStyle, divStyle1]&quot;&gt;i am a div&lt;/div&gt; &lt;button @click=&quot;fn1(1)&quot;&gt;click&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el: &#39;#app&#39;, data:{ a:1, dom:&#39;&lt;div&gt;ls&lt;/div&gt;&#39;, flag:true, count: 3， imgUrl：&#39;https://i.loli.net/2019/11/12/UmZdgG8HuJ1AMPb.jpg&#39;, divStyle: {width: &#39;100px&#39;, height: &#39;100px&#39;, backgroundColor: &#39;red&#39;}, divStyle1: { color: &#39;#fff&#39;}, //属性名和函数名不能重复 }, methods: { fn1(a){ console.log(a); } } }) &lt;/script&gt; v-for 循环 &lt;div id=&quot;app&quot;&gt; &lt;!-- 遍历数组，需要添加唯一key值，最好不用index --&gt; &lt;button @click = &quot;onclick&quot;&gt;Click&lt;/button&gt; &lt;div v-for=&quot;item in nameArr&quot; :key=&quot;item.id&quot;&gt;{{item.name}}&lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;!-- 遍历对象，(value,key) --&gt; &lt;div v-for=&quot;(value,key) in person&quot; &gt;{{key}} : {{value}}&lt;/div&gt; &lt;br&gt; &lt;!-- 遍历数字 --&gt; &lt;!-- &lt;div v-for=&quot;item in 10&quot;&gt;{{item}}&lt;/div&gt; --&gt; &lt;br&gt; &lt;!-- 遍历字符串 --&gt; &lt;!-- &lt;div v-for=&quot;item in &#39;lushuo&#39;&quot;&gt;{{item}}&lt;/div&gt; --&gt; &lt;!-- 渲染多个循环，用&lt;template&gt;包裹，但是&lt;template&gt;不能绑定key值，要绑在内部元素，且每个不能相同 --&gt; &lt;template v-for=&quot;(item,index) in arr&quot;&gt; &lt;div :_key=&quot;`${index}_1`&quot; :key=&quot;`${index}_1`&quot;&gt;{{index}}&lt;/div&gt; &lt;span :_key=&quot;`${index}_2`&quot; :key=&quot;`${index}_2`&quot;&gt;{{item}}&lt;/span&gt; &lt;/template&gt; &lt;br&gt; &lt;br&gt; &lt;!-- key值的另一作用：在dom元素相同时，进行区分。如例子中input为相同dom，vue默认会进行复用，导致填的内容不会随着功能切换而改变，加key值解决 --&gt; &lt;div v-if=&quot;flag&quot;&gt; &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; key=&quot;name&quot;&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;label for=&quot;age&quot;&gt;年龄&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;age&quot; key=&quot;age&quot;&gt; &lt;/div&gt; &lt;button @click=&quot;change&quot;&gt;互换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el:&#39;#app&#39;, data:{ arr:[1,2,3], //nameArr:[&#39;ls&#39;,&#39;dh&#39;,&#39;bb&#39;] //后台返回的数据，一般都有一个id对应 nameArr:[ { name:&#39;ls&#39;, id:201901 }, { name:&#39;dh&#39;, id:201902 }, { name:&#39;bb&#39;, id:201903 } ], person:{ name:&#39;ls&#39;, desc:&#39;boy&#39;, age:23 }, flag:true }, methods:{ onclick(){ this.nameArr.reverse(); }, change(){ this.flag = !this.flag; } } }) &lt;/script&gt; v-model 数据双向绑定，value+input语法糖修饰符 v-model.lazy变成value与change事件得语法糖 v-model.number将输入得数字字符串转成数字 v-model.trim去掉字符串前后空格 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;content[0]&quot;&gt;&lt;br&gt; &lt;textarea v-model=&quot;content1&quot;&gt;&lt;/textarea&gt;&lt;br&gt; {{ content1}} &lt;br&gt; &lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;checked1&quot; /&gt; {{ checked1 }} --&gt; &lt;br&gt; &lt;label for=&quot;cg&quot;&gt;1&lt;/label&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot; id=&quot;cg&quot; value=&quot;cgg&quot; /&gt; &lt;label for=&quot;dg&quot;&gt;2&lt;/label&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot; id=&quot;dg&quot; value=&quot;dgg&quot; /&gt; &lt;label for=&quot;stg&quot;&gt;3&lt;/label&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot; id=&quot;stg&quot; value=&quot;stgg&quot; /&gt; &lt;br&gt; {{ checked }} &lt;!-- 多选存的value值 --&gt; &lt;br&gt; &lt;br&gt; &lt;label for=&quot;one&quot;&gt;one&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;one&quot; v-model=&quot;picked&quot;/&gt; &lt;label for=&quot;two&quot;&gt;two&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;two&quot; v-model=&quot;picked&quot; /&gt; {{ picked }} &lt;br&gt;&lt;br&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;&quot; disabled&gt;请选择&lt;/option&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;/select&gt; {{ selected }} &lt;br&gt; &lt;br&gt; &lt;select v-model=&quot;selected&quot; multiple&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;/select&gt; {{ selected }} &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el: &#39;#app&#39;, data: { content: [&#39;hello&#39;,&#39;&#39;,&#39;&#39;], content1:[], // checked: true checked: [], checked1: [], picked: &#39;&#39;, //selected: &#39;&#39; selected: [], show: [false,true], }, mathods:{ } }) &lt;/script&gt;","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"hexo多电脑配置","slug":"hexo多电脑配置","date":"2019-11-11T01:29:26.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/11/11/hexo多电脑配置/","link":"","permalink":"/2019/11/11/hexo多电脑配置/","excerpt":"","text":"hexo多台电脑配置最近买了新电脑，要把旧电脑上的hexo博客配置转移过来，记录下过程。 1.备份博客原文件先在github博客仓库新建backup分支，在hexo配置文件_config.yml中添加如下配置： # backup backup: type: git message: backup my blog of https://mintaco.github.io/ repository: github: git@github.com:MINTACO/MINTACO.github.io.git,backup 其中仓库地址自行更改；执行hexo backup 2.新电脑安装git,node环境安装完后配置git用户名，邮箱及ssh密钥 3.克隆backup分支到新电脑本地4.复制原电脑中的.ssh文件夹中文件到新电脑的对应文件夹中不复制的话没法deploy","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"/tags/Tools/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"测试","slug":"测试-1","date":"2019-11-10T11:14:07.000Z","updated":"2019-12-26T02:11:30.678Z","comments":true,"path":"2019/11/10/测试-1/","link":"","permalink":"/2019/11/10/测试-1/","excerpt":"","text":"","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"测试","slug":"测试","date":"2019-11-10T11:07:43.000Z","updated":"2019-12-17T08:55:15.924Z","comments":true,"path":"2019/11/10/测试/","link":"","permalink":"/2019/11/10/测试/","excerpt":"","text":"","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"好用的控制台模拟器Cmder","slug":"好用的控制台工具Cmder","date":"2019-11-10T10:30:58.000Z","updated":"2019-12-26T02:11:30.677Z","comments":true,"path":"2019/11/10/好用的控制台工具Cmder/","link":"","permalink":"/2019/11/10/好用的控制台工具Cmder/","excerpt":"","text":"Cmder安装及简单配置1.cmder简介小巧强大的控制台模拟器，相比原生win控制台，界面更美观，复制粘贴更方便，支持分屏等，且有强大的快捷操作键，开发更高效。 2.安装官网cmder下载安装，最好下载完整版，支持git。 3.简单配置3.1配置环境变量计算机属性——高级系统设置——环境变量——系统变量，将cmder安装路径添加到PATH中。 3.2将cmder添加到鼠标右键菜单管理员身份开启cmd，运行Cmder.exe /REGISTER ALL 3.3解决中文乱码Settings-&gt;Startup-&gt;Environment 添加set LANG=zh_CN.UTF-8 4.常用快捷键Tab 自动路径补全 Ctrl+T 建立新页签 Ctrl+W 关闭页签 Ctrl+Tab 切换页签 Alt+F4 关闭所有页签 Alt+Shift+1 开启cmd.exe Alt+Shift+2 开启powershell.exe Alt+Shift+3 开启powershell.exe (系统管理员权限) Ctrl+1 快速切换到第1个页签 Ctrl+n 快速切换到第n个页签( n值无上限) Alt + enter 切换到全屏状态 Ctr+r 历史命令搜索","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"/tags/Tools/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"又一个普通的周末","slug":"又一个普通的周末","date":"2019-11-10T10:10:18.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/11/10/又一个普通的周末/","link":"","permalink":"/2019/11/10/又一个普通的周末/","excerpt":"","text":"周末总是睡不够，今天是lol总决赛的日子，希望FPX赢吧","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"MarkDownPad2常用快捷键","slug":"MarkDownPad2常用快捷键","date":"2019-10-31T08:59:52.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/10/31/MarkDownPad2常用快捷键/","link":"","permalink":"/2019/10/31/MarkDownPad2常用快捷键/","excerpt":"","text":"Ctrl + I ： 斜体 Ctrl + B ： 粗体 Ctrl + G ： 图片 Ctrl + Q ： 引用 Ctrl + 1 ： 标题 1 Ctrl + 2 ： 标题 2 Ctrl + 3 ： 标题 3 Ctrl + K ： 代码块 Ctrl + L ： 超链接 Ctrl + T ： 时间戳 Ctrl + U ： 无序列表 Ctrl + R ： 水平标尺 F4 ： 启用水平布局 F5 ： 启用实时预览 F6 ： 在浏览器中预览 Ctrl + Shift + O ： 有序列表 本文参考 版权声明：本文为CSDN博主「陈凯冰」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：MarkdownPad 2 常用快捷键","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"/tags/Tools/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"MarkDown基本语法","slug":"MarkDown基本语法","date":"2019-10-31T08:58:44.000Z","updated":"2019-12-26T02:11:30.667Z","comments":true,"path":"2019/10/31/MarkDown基本语法/","link":"","permalink":"/2019/10/31/MarkDown基本语法/","excerpt":"","text":"标题# 一级标题## 二级标题### 三级标题。。。最大支持六级标题，注意#后加空格 换行行尾加两个空格 原文中显示#,*,&gt;等符号加转义符\\ 缩进使用空格字符进行缩进，如&amp;emsp;&amp;emsp;,缩进两字符,注意结尾分号 html中的常见空格实体（不完全） 空格分类 含义 ‘&amp;nbsp’ 不换行空格，全称是 No-Break Space，即按下space键产生的空格。在HTML代码中，连续使用空格键产生此空格，空格不会累加，即在网页中只显示一个空格。只有使用实体才可累加，该空格占据宽度受字体影响。 ‘&amp;ensp’ 半角空格，全称En Space。en是字体排印学的计量单位，为em宽度的一半。特性稳健，宽度为中文字符宽度的一半，且不受字体影响。 ‘&amp;emsp’ 全角空格，全称是 Em Space。em是字体排印学的计量单位，相当于当前指定的点数。例如，1 em在16px的字体中就是16px。占据的宽度正好是1个中文宽度，而且基本上不受字体影响。 ‘&amp;thinsp’ 窄空格，全称是 Thin Space。占据的宽度比较小，它是em之六分之一宽。 文本强调加粗文本左右两侧加**，且不能有空格 斜体文本左右两侧加*，且不能有空格 斜体加粗文本左右两侧加***，且不能有空格 删除线文本左右两侧加~~,且不能有空格 下划线文本左右两侧加&lt;u&gt;&lt;/u&gt;,且不能有空格 分隔线三个* 引用引用的文字前加&gt;即可，引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 链接 行内形式：[超链接名](超链接地址 &quot;超链接描述&quot;) 参考形式：为参考形式的链接定一个 [名称] 方便我们在文章中多次引用（链接名称可以用字母、数字和空格，但是不分大小写）。 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要用 &lt; &gt; 包起来，如&lt;https://www.baidu.com&gt; 插入图片图片的语法和链接很像。alt text 是替换文本；alt 属性规定在图像无法显示时的替代文本。虽然 alt text 可以不填，但推荐还是填上。Title 是可选项。 行内样式![alt text](/path/to/img.jpg &quot;Title&quot;) 参考样式 ![alt text][id] [id]: /path/to/img.jpg &quot;Title&quot; 代码块与高亮插入程序代码的方式有两种：使用反引号 `（~ 键）、使用缩进（Tab）。 插入行内代码，即插入一个单词或者一句代码的情况，使用 ` 插入。 插入多行代码，分别使用三个反引号（`）包裹多行代码。或者使用缩进。 列表有序列表 数字 + 英文句号 + 空格 + 列表内容 无序列表星号/加号/减号 + 空格 + 列表内容","categories":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"/tags/Tools/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"/categories/开发/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2019-11-10T12:08:19.724Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"/tags/Tools/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]}]}